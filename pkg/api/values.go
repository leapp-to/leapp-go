package api

import (
	"encoding/json"
	"net/http"

	"github.com/leapp-to/leapp-go/pkg/executor"
	"github.com/pkg/errors"
)

// CKey represents a key to be used in context.Context.
type CKey string

type cmdFunc func(*http.Request) (*executor.Command, error)

type respFunc func(http.ResponseWriter, *http.Request) (interface{}, int, error)

// Error codes sent to clients.
// We are explicity assigning the values so them can be easily checked.
const (
	errInternal       = 1
	errBadInput       = 2
	errNotFound       = 4
	errTaskNotFound   = 5
	errTaskRunning    = 6
	errTaskExecution  = 7
	errActorExecution = 8
)

// apiError represents an error to be returned to the client.
type apiError struct {
	err  error
	code int
	msg  string
}

// Error implements the error interface for apiError.
func (e apiError) Error() string {
	if e.err != nil {
		err := errors.Wrap(e.err, e.msg)
		return err.Error()
	}
	return e.msg
}

// MarshalJSON implements the Marshaler interface for apiError.
func (e apiError) MarshalJSON() ([]byte, error) {
	var out = struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
	}{
		Code:    e.code,
		Message: e.Error(),
	}
	return json.Marshal(out)
}

// newAPIError returns a new apiError object.
func newAPIError(e error, c int, m string) apiError {
	if c == 0 {
		c = errInternal
	}
	return apiError{err: e, code: c, msg: m}
}

// apiResult contains the information generated by and endpoint handler.
type apiResult struct {
	Errors []apiError  `json:"errors,omitempty"`
	Data   interface{} `json:"data,omitempty"`
}

//ObjValue wraps any value into a JSON object with a key "value".
type ObjValue struct {
	Value interface{} `json:"value"`
}

// PortForwarding is a mapping between a port in the container and a port exposed by the host.
type PortForwarding struct {
	Protocol    string `json:"protocol"`
	ExposedPort uint16 `json:"exposed_port"`
	Port        uint16 `json:"port"`
}

// PortForwardingSlice contains all ports that should be exposed by the host.
type PortForwardingSlice []PortForwarding

// MarshalJSON makes sure that a nil PortForwardingSlice becomes an empty JSON list.
func (f PortForwardingSlice) MarshalJSON() ([]byte, error) {
	if f == nil {
		return []byte("[]"), nil
	}
	return json.Marshal([]PortForwarding(f))
}

// TCPPortsUserMapping represents the high level JSON object containing all ports that should be exposed by the host.
type TCPPortsUserMapping struct {
	Ports PortForwardingSlice `json:"ports"`
}

// PortMapping represents a map of ports and the names of their respective services.
type PortMapping map[uint16]map[string]string

// MarshalJSON makes sure that a nil PortMapping becomes an empty JSON object.
func (m PortMapping) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("{}"), nil
	}
	return json.Marshal(map[uint16]map[string]string(m))
}

// ExcludedTCPPorts represents the high level JSON object containing all ports that should not be exposed by the target host.
type ExcludedTCPPorts struct {
	TCP PortMapping `json:"tcp"`
	UDP PortMapping `json:"udp"`
}
